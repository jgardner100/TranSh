#!/bin/mysh

#include "ext.my"

#
# chk-proxy.my
#
# Check where proxy tables point to.
#
# Author: John Gardner
# Date: 1 April 2010
#

global str TMPFILE;
global str TMPPROXY;
global str TMPERR;

do_init

TMPFILE="$TMPDIR/proxy-out-$$.txt";
TMPPROXY="$TMPDIR/proxy-out-$$.sql";
TMPERR="$TMPDIR/proxy-err-$$.txt";

proc dump_sysstat( str P_DBNAME, str P_TABLE) {

	str STAT;

	do_verbose( "dump_sysstat() $P_DBNAME $P_TABLE");

	do_isql( "$DBNAME", "select '#'+
				convert(varchar(4),(sysstat2&2048))+'#'
			from
				sysobjects 
			where 
				(sysstat2 & 1024) = 1024
				and type = 'U'
				and name = '$P_TABLE'
	");
	do_verbose( "RES=$RES");

	STAT=$(echo "$RES"|cut -d# -f2);
	if [ "$STAT" = "2048" ] then
		printf "Create Exists ";
	else
		printf "Not Create Exists $STAT ";
	fi
}

#
# Dump to a file the sql to create the proxy table
#
proc dump_tofile( str T_DBNAME, str T_TABLE) {

	echo $T_DBNAME/$T_TABLE;

        ddlgen -U$DBUSER -I$SYBASE/interfaces -S$DSQUERY -P$DBPASSWD \
                -D$T_DBNAME -TU -XOD -N$T_TABLE -O$TMPFILE -E$TMPERR ;
        checkret "$?" "ddl out failed for $T_DBNAME.$T_TABLE";

        grep " at " $TMPFILE;

	cp $TMPFILE $BACKUP_DIR/$DSQUERY-proxy-$T_DBNAME-${T_TABLE}.sql;

}

#
# Just dump where the proxy table points to
#
proc dump_proxy( str P_DBNAME, str P_TABLE) {

	do_verbose( "dump_proxy() $P_DBNAME $P_TABLE");

	echo $P_DBNAME/$P_TABLE;

	do_isql( "$P_DBNAME", "select convert(varchar(60),'#'+char_value+'#') from sysattributes
			where class = 9 and attribute = 1 and
			object_cinfo = '$P_TABLE'
	");

	checkret( "$?", "select proxy table details failed", "nolog");

	RES=$(cat <<EOS | cut -f2 -d# | head -1 | grep -v "^EOS"
$RES
EOS
);
	echo "	$RES";

	do_verbose( "RES=$RES");
}

proc check_exists( str P_DBNAME, str P_TABLE) {

        do_isql( "$P_DBNAME", "
                        select convert(varchar(60),'#'+name+'#') a
                                from sysobjects
                                where
                                        (sysstat2 & 1024) = 1024
                                and type = 'U'
                                and name = '$P_TABLE'
        ");
        checkret( "$?", "Can't select table!", "nolog");

	do_verbose( "RES1=$RES");
        RES=$(cat <<EOS|cut -d# -f2|grep -v "^EOS"
$RES
EOS
);
	do_verbose( "RES2=[$RES], P_TABLE=[$P_TABLE]");

        if [ "$RES" = "$P_TABLE" ] then
                return 1;
        else
                return 0;
        fi
}

proc process_indb() {

	int RETVAL;

	for DBNAME in $DB_LIST
	do
	
		#
		# Find all proxy tables in the database
		#
		do_isql( "$DBNAME", "select ':'+name+':'
				from sysobjects 
				where 
					(sysstat2 & 1024) = 1024
				and type = 'U'
				order by name
		");
		RETVAL="$?";

		#
		# Note, need to skip failed access to databases (retval = 2)
		#
		if [ "$RETVAL" -ne 2 ] then
	
			checkret( "$RETVAL", "select table types failed", "nolog");

			if [ "$RETVAL" -eq 0 ] then

				RES=$(cat <<EOS|cut -f2 -d:|grep -v "^EOS"
$RES
EOS
);

				for TABLE in $RES
				do
					if [ -z "$JUST_DUMP" ] then
						dump_sysstat( "$DBNAME", "$TABLE");
						dump_proxy( "$DBNAME", "$TABLE");
					else
						dump_tofile( "$DBNAME", "$TABLE");
					fi
				done
				if [ ! -z "$VERBOSE" ] then
					display( "$RES");
				fi
			fi

		fi
	done
}

proc process_incfg() {

	str ACTION, DBNAME, TABLE, UNAME;

        get_param( "$TMPENV", "proxy_action");
        ACTION="$PVAL";

        echo "Action = $ACTION";

        for ENTRY in $PROXY_LIST
        do
                DBNAME=$(echo $ENTRY|cut -d: -f1);
                TABLE=$(echo $ENTRY|cut -d: -f2);
                UNAME=$(echo $ENTRY|cut -d: -f3);

                echo check_exists $DBNAME $TABLE;
                check_exists( "$DBNAME", "$TABLE");
                if [ "$?" -ne 0 ] then
                	do_verbose( "do ddl_proxy $DBNAME.$TABLE");
			dump_proxy( "$DBNAME", "$TABLE");
                else
			echo;
			echo "SKIP $DBNAME.$TABLE - IT DOESN'T EXIST!";
                fi

	done
}

proc usage( str ARGV) {

	str NAME;

        NAME=$(basename "$ARGV");

        echo "usage: $NAME [-v][-d] dataserver";
	echo "";
        echo " -v = verbose output";
        echo " -x = extra verbose output";
        echo " -d = dump sql for proxy tables";
        echo " -a = do all proxy tables in database";
        echo " -e = env to use (ie FSGDEV2-TST1)";
        echo " -u = database user to login as";

        exit(1);

}

getopt "e:,USE_ENV,u:,USE_USER,v,VERBOSE,d,JUST_DUMP,a,DO_ALL,x,VERBOSE";

if [ $# -ne 1 ] then
        usage( "$0");
fi

setdb( "$1", $USE_USER);

get_envfile( "$TMPENV");

if [ ! -z "$DO_ALL" ] then
	process_indb;
else
	process_incfg;
fi

rm -f "$TMPFILE" "$TMPPROXY" "$TMPERR";

do_finish
