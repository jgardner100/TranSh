#!/bin/mysh

#include "ext.my"

#
# copy-objs.sh - Copy out or in a list of tables and stored procedures to save them across the refresh.
#
# Author: John Gardner
# Date: 1 June 2010
#

global str DIR;

do_init

str BCPOPTS="-c -t |";

proc chk_err( str FILE) {

	str ERR, ERR1, ERR3, ERR4, ERR5, ERR6, ERR7, ERR8;
	int RETVAL;

	if [ ! -f "$FILE" ] then
		echo "No such file $FILE";
		return 1;
	fi

	ERR1=$(cat $FILE|grep "Msg ");
	ERR3=$(cat $FILE|grep "DB-LIBRARY error ");
	ERR4=$(cat $FILE|grep "CT-LIBRARY error ");
	ERR5=$(cat $FILE|grep "CSLIB Message");
	ERR6=$(cat $FILE|grep "password incorrect for user");
	ERR7=$(cat $FILE|grep "is not a valid user in database");
	ERR8=$(cat $FILE|grep "Unrecoverable I/O or volume error");

	if [ -z "$ERR1" -a -z "$ERR2" -a -z "$ERR3" -a -z "$ERR4" \
                        -a -z "$ERR5" -a -z "$ERR6" -a -z "$ERR7" \
			-a -z "$ERR8" ] then
		ERR="$ERR1 $ERR2 $ERR3 $ERR4 $ERR5 $ERR6 $ERR7 $ERR8";
		RETVAL=0;
	else
		RETVAL=1;
	fi

	#RES=$(cat $FILE|grep -v "rows sent to SQL Server");
	#RES=$(grep -v "rows sent to SQL Server" $FILE);

	return $RETVAL;
}

proc exp_out( str TABLES) {

	str DB, NAME, FILE;
	str OPTS="-U$DBUSER -S$DSQUERY $BCPOPTS";

	do_verbose "Tables=$TABLES";

	for TABLE in $TABLES
	do
		DB=$(echo $TABLE|cut -d. -f1);
		NAME=$(echo $TABLE|cut -d. -f2);

		FILE="$BACKUP_DIR/$DSQUERY-$NAME.out";

		echo "Doing table $TABLE to $FILE";
		exp "userid=${DBUSER}/${DBPASSWD}@${SID}" "tables=${TABLE}" "file=${FILE}" "rows=y" "grants=y" "indexes=y";
	done
}

proc bcp_out( str TABLES) {

	str DB, NAME, FILE;
	str OPTS="-U$DBUSER -S$DSQUERY $BCPOPTS";

	do_verbose "Tables=$TABLES";

	for TABLE in $TABLES
	do
		DB=$(echo $TABLE|cut -d. -f1);
		NAME=$(echo $TABLE|cut -d. -f2);

		FILE="$BACKUP_DIR/$DSQUERY-$NAME.out";

		do_verbose "$DB.dbo.$NAME: $FILE";
		do_verbose bcp "$DB.dbo.$NAME" out $FILE $OPTS;
		bcp "$DB.dbo.$NAME" out $FILE $OPTS >$ERRFILE <<
$DBPASSWD
>;

		chk_err $FILE;
		if [ "$?" -ne 0 ] then
			echo "Err: Bcp out failed! $ERR";
			log_error "bcp" "Bcp out failed $DB.$NAME";
		else
			tail $TAIL_OPT -10 $ERRFILE; | grep "rows copied";
		fi

		rm -f $ERRFILE;
	done
}

proc truncate_all( str TABLES) {

	str DB, NAME;

	for TABLE in $TABLES
	do

		DB=$(echo $TABLE|cut -d. -f1);
		NAME=$(echo $TABLE|cut -d. -f2);

		do_isql "$DB" "truncate table $NAME";
		checkret "$?" "truncate table $DB.$NAME failed!";
		display "truncate table $DB.$NAME $RES";

	done
}

proc exp_in( str TABLES) {

	str DB, NAME, FILE;
	str OPTS="-U$DBUSER -S$DSQUERY $BCPOPTS";

	for TABLE in $TABLES
	do
		DB=$(echo $TABLE|cut -d. -f1);
		NAME=$(echo $TABLE|cut -d. -f2);

		FILE="$BACKUP_DIR/$DSQUERY-$NAME.out";

		imp "userid=${DBUSER}/${DBPASSWD}@${SID}" "tables=${TABLE}" "file=${FILE}" "rows=n" "ignore=n";
	done
}

proc bcp_in( str TABLES) {

	str DB, NAME, FILE, RES;
	str OPTS="-U$DBUSER -S$DSQUERY $BCPOPTS";

	for TABLE in $TABLES
	do
		DB=$(echo $TABLE|cut -d. -f1);
		NAME=$(echo $TABLE|cut -d. -f2);

		do_verbose "$DB.dbo.$NAME";

		split -l 100000 $BACKUP_DIR/$DSQUERY-$NAME.out $BACKUP_DIR/x;

		do_isql "$DB" "dump tran $DB with truncate_only";
		checkret "$?" "dump tran $DB failed!";

		for FILE in $BACKUP_DIR/x*
		do
			do_isql "$DB" "dump tran $DB with truncate_only";
			checkret "$?" "dump tran $DB failed!";

			do_verbose bcp "$DB.dbo.$NAME" "in" $FILE $OPTS;
			bcp "$DB.dbo.$NAME" "in" $FILE $OPTS >$ERRFILE <<
$DBPASSWD
>;

			chk_err $ERRFILE;
			if [ "$?" -ne 0 ] then
				echo "Err: Bcp in failed!";
				RES=$(grep -v "rows sent to SQL Server" $ERRFILE);
				echo "$RES";
				log_error "bcp" "Bcp in failed $DB.$NAME";
			else
				tail $TAIL_OPT -10 $ERRFILE; | grep "rows copied";
			fi

			rm -f $FILE $ERRFILE;

		done

		do_isql "$DB" "dump tran $DB with truncate_only";
		checkret "$?" "dump tran $DB failed!";

	done
}

proc ddl_out( str TYPE, str LIST) {

	str OBJ, DB, NAME;

	for OBJ in $LIST
	do
		DB=$(echo $OBJ|cut -d. -f1);
		NAME=$(echo $OBJ|cut -d. -f2);

		do_verbose "dumping sql for $NAME in $DB, type = $TYPE";

		do_ddl $DB $TYPE $NAME "$BACKUP_DIR/${DSQUERY}-${NAME}-out.sql";
		checkret "$?" "ddl out failed for $DB.$NAME";
	done
}

proc ddl_in( str TYPE, str LIST) {

	str OBJ, DB, NAME, SQL;

	for OBJ in $LIST
	do
		DB=$(echo $OBJ|cut -d. -f1);
		NAME=$(echo $OBJ|cut -d. -f2);

		SQL=$(cat <$BACKUP_DIR/${DSQUERY}-${NAME}-out.sql);

		do_isql "$DB" "$SQL";
		checkret "$?" "Can't exec sql for $DB..$NAME!";

		display "$RES";

		do_verbose "loading sql for $NAME in $DB";
	done
}

proc usage() {

	str NAME;

	NAME=$(basename $1);

	echo "usage: $NAME [-e env][-u user][-v] dataserver direction";
	echo "";
	echo " -v = verbose output";
	echo " -e = env to use (ie FSGDEV2-TST1)";
	echo " -u = database user to login as";
	echo "";

	exit 1;
}

getopt "v,VERBOSE,d:,DBARG,e:,USE_ENV,u:,USE_USER";

if [ $# -ne 2 ] then
	usage $0;
fi

setdb "$1" $USE_USER;
DIR="$2";

get_envfile "$TMPENV";

case $DIR in
	"out")
		if [ "$DBTYPE" = "ORACLE" ] then
			do_verbose "Bcp Out data = ${SAVE_DATA}";
			exp_out "${SAVE_DATA}";
		else
			do_verbose "Bcp Out tables";
			ddl_out "U" "${SAVE_TABLE}";

			do_verbose "Bcp Out data = $SAVE_DATA";
			bcp_out "${SAVE_DATA}";

			do_verbose "Bcp Out procs ${SAVE_PROCS}";
			ddl_out "P" "${SAVE_PROCS}";
		fi
		;;
	"in")
		if [ "$DBTYPE" = "ORACLE" ] then
			do_verbose "Bcp In data for ${SAVE_DATA}";
			exp_in "${SAVE_DATA}";
		else
			do_verbose "Bcp In tables";
			ddl_in "U" "${SAVE_TABLE}";

			do_verbose "Bcp In data";
			truncate_all "${SAVE_DATA}";
			bcp_in "${SAVE_DATA}";

			do_verbose "Bcp In procs";
			ddl_in "P" "${SAVE_PROCS}";
		fi
		;;
	*)
		echo "Bad direction $DIR";
		usage;
		;;
esac

do_finish
