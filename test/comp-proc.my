#!/bin/mysh

#
# get-prot.my
#
# Get the full list of grants for objects
#
# Author: John Gardner
# Date: 1 Nov 2016
#

#include "ext.my"

str TARGETDS, SOURCEDS;
str USE_FILE="Y";
str TOTAL_COUNT="0";
str OBJ_TYPE="U";

do_init

#
# Send the output to a specified filename
#
proc to_file( str P_FNAME, str P_TEXT) {

	do_verbose "Got P_FNAME=$P_FNAME & P_TEXT=$P_TEXT";
	if [ \( ! -z "$USE_FILE" \) -a \( -z "$P_FNAME" \) ] then
		echo "No Filename!";
		exit 1;
	elif [ \( ! -z "$USE_FILE" \) -a \( ! -z "$P_FNAME" \) ] then
		echo "$P_TEXT" >> $HOME/refresh/tmp/$P_FNAME;
	else
		echo "$P_TEXT";
	fi
}

#
# Get the actual permissions for the object
#
proc get_prot_details( str OBJECT, str FNAME) {

	str CHECKSTR, OBJECT;

	do_verbose "** do_isql $P_TARGETDB sp_helpermission '$OBJECT' **";
	CHECKSTR=$(echo "$OBJECT" | grep "^dbo");
	if [ ! -z "$CHECKSTR" ] then
		echo "Got checkstr";
		OBJECT=$(echo $OBJECT|cut -d\. -f2);
	fi
	do_verbose "PROCL=$OBJECT";
	#do_isql "$P_TARGETDB" "sp_helpermission '$OBJECT'"
	#checkret "$?" "sp_helpermission failed for $OBJECT"
	do_isql "$P_TARGETDB" "sp_helprotect '$OBJECT'";
	checkret "$?" "sp_helprotect failed for $OBJECT";
	do_verbose "do_isql result is $RES";
	if [ "$?" -ne 0 ] then
		checkret "1" "Can't select permissions for $OBJECT" "nolog";
	else

		if [ ! -z "$RES" ] then
			echo "$RES"; | while read LINE
			do
				to_file "${FNAME}.sql" "$LINE";
			done
		else
			echo "Empty perms for $OBJECT";
		fi
	fi
}

proc check( str P_TARGETDS, str P_DIR, str P_WHAT, str P_KEYWORD, str P_TARGETDB) {

	str TXT, TEXT;

	RES=$(tr -s "[:blank:]" <$HOME/refresh/tmp/a2.sql | awk '{print $3,$4,"on",$5,"to",$2}' >$HOME/refresh/tmp/a3.sql);
	RES=$(tr -s "[:blank:]" <$HOME/refresh/tmp/b2.sql | awk '{print $3,$4,"on",$5,"to",$2}' >$HOME/refresh/tmp/b3.sql);

	TXT=$(diff "$HOME/refresh/tmp/a3.sql" "$HOME/refresh/tmp/b3.sql"|grep "$P_DIR"|grep -v wrap_support_grp);

	if [ ! -z "$TXT" ] then
		echo "$P_WHAT on $P_TARGETDS:";
		TEXT=$(diff "$HOME/refresh/tmp/a3.sql" "$HOME/refresh/tmp/b3.sql"|grep "$P_DIR"|sed "s/^$P_DIR //"|sed "s/^Grant /$P_KEYWORD /"|grep -v wrap_support_grp);

		if [ -z "$EXEC_SQL" ] then
			display "$TEXT";
		else
			echo "Doing:";
			display "$TEXT";
			do_isql "$P_TARGETDB" "$TEXT";
			checkret "$?" "couldn't change permissions for $P_TARGETDS.$P_TARGETDB";
			echo "do_isql result is $RES";
		fi
	fi
}

#
# Check that the object exists in the database
#
proc check_exists( str P_OBJECT, str P_DSNAME) {

	do_isql "$P_TARGETDB" "select name from sysobjects where name = '$P_OBJECT'";
	checkret "$?" "Can't check for object $P_OBJECT";

	RES=$(echo $RES);

	if [ -z "$RES" ] then
		echo "NO";
	fi

	echo "YES";
}

#
# Loop over each object in the databases and dump the perms
#
proc get_prot_list( str P_TARGETDB, str P_TYPE) {

	str PROCLIST, PROCL, CHECKSTR, EXISTS;
	int COUNT;

	setdb "$SOURCEDS" $USE_USER;
	do_verbose "do_isql $P_TARGETDB select name from sysobjects where type = '$P_TYPE'";

	do_isql "$P_TARGETDB" "select count(*) from sysobjects where type = '$P_TYPE' and name not like 'rs_%'";
	checkret "$?" "Can't count proc names for $P_TARGETDB";
	TOTAL_COUNT=$(echo $RES);

	do_isql "$P_TARGETDB" "select name from sysobjects where type = '$P_TYPE' and name not like 'rs_%'";
	checkret "$?" "Can't select proc names for $P_TARGETDB";
	PROCLIST="$RES";
	do_verbose "PROCLIST=$PROCLIST";

	COUNT=0;
	for PROCL in $PROCLIST
	do
		echo "$COUNT of $TOTAL_COUNT - $P_TARGETDB, $PROCL";

		rm -f "$HOME/refresh/tmp/a1.sql" "$HOME/refresh/tmp/a2.sql";
		touch "$HOME/refresh/tmp/a1.sql" "$HOME/refresh/tmp/a2.sql";

		rm -f "$HOME/refresh/tmp/b1.sql" "$HOME/refresh/tmp/b2.sql";
		touch "$HOME/refresh/tmp/b1.sql" "$HOME/refresh/tmp/b2.sql";

		setdb "$SOURCEDS" $USE_USER;
		EXISTS=$(check_exists "$PROCL" "$SOURCEDS");
		if [ "$EXISTS" = "YES" ] then
			get_prot_details "$PROCL" "b1";

			setdb "$TARGETDS" $USE_USER;
			EXISTS=$(check_exists "$PROCL" "$TARGETDS");
			if [ "$EXISTS" = "YES" ] then
				get_prot_details "$PROCL" "a1";
	
				sort <"$HOME/refresh/tmp/a1.sql" >"$HOME/refresh/tmp/a2.sql";
				sort <"$HOME/refresh/tmp/b1.sql" >"$HOME/refresh/tmp/b2.sql";
	
				check "$TARGETDS" "<" "Revoke" "revoke" "$P_TARGETDB";
				check "$TARGETDS" ">" "Missing" "grant" "$P_TARGETDB";
			else
				echo "No object $PROCL in $TARGETDS.$P_TARGETDB";
			fi
		else
			echo "No object $PROCL in $SOURCEDS.$P_TARGETDB";
		fi

		COUNT=$(expr $COUNT + 1);
	done
}

#
# Dump the cmd usage and exit
#
proc usage( str ARGV) {

	str NAME;

	NAME=$(basename $ARGV);
	echo "$NAME : [-e env][-u user][-f][-v][-t][-d database] source target";

	echo "";
	echo " -v = verbose, output extra messages";
	echo " -t = test run, don't actually run changes ";
	echo " -d database = run for this database only ";
	echo " -e = env to use (ie FSGDEV2-TST1)";
	echo " -f = output to files in $HOME/refresh/backups";
	echo " -o = object type [U,V,P] (default = U)";
	echo " -h = display this message";
	echo " -u = database user to login as";
	echo " -x = exec the sql to update the premissions";
	echo "";

	exit 1;
}

getopt "u:,USE_USER,e:,USE_ENV,d:,DB_NAME,o:,OBJ_TYPE,v,VERBOSE,t,TESTMODE,f,USE_FILE,x,EXEC_SQL";

if [ "$#" -ne 2 ] then
	usage $0;
fi

SOURCEDS="$1";
TARGETDS="$2";

echo "Doing object type of $OBJ_TYPE";

setdb "$TARGETDS" $USE_USER;

if [ -z "$DB_NAME" ] then

	get_envfile "$TMPENV";

	echo "do all databases on $DSNAME";
	for TARGET in $DB_LIST
	do
		get_prot_list "$TARGET" "$OBJ_TYPE";
	done

	rm -f "$TMPENV";

else
	get_prot_list "$DB_NAME" "$OBJ_TYPE";
fi

do_finish
